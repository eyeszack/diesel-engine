{"name":"diesel-engine","tagline":"A simple framework for building DSLs with Groovy.","body":"## Introduction\r\n\r\nI'm going to assume that you're already familiar with DSLs and Groovy if you're interested in this project. The intention behind creating diesel engine was quite simple, to quickly build DSLs. Also important was to keep this easy and reusable, so very simple patterns were used in building the initial engine.\r\n\r\n## Developer Guide\r\n\r\nIn diesel engine you'll find a single core class that does all the work, it bootstraps your DSL by finding and loading your DSL's keywords and language extensions at runtime. This is done by using a nice feature provided by Java\r\ncalled the **Service Provider Interface (SPI) API**. I won't spend much time detailing the SPI for you, if you wish to read more about it see [this Java turtorial](http://docs.oracle.com/javase/tutorial/sound/SPI-intro.html).\r\nThe core class is the [DSLEngineScript](src/me/dslengine/DSLEngineScript.groovy) class, it extends Groovy's Script class and adds your keywords to its meta-class and loads any extensions. The other classes used by the engine are \r\nthe [KeywordProvider](src/me/dslengine/keyword/KeywordProvider.groovy) interface and the [Keyword](src/me/dslengine/keyword/Keyword.groovy) class. You'll use these two classes to implement the actual keywords to be used in your DSL. \r\nAnd if you want to extend the Groovy language you would implment the [LanguageExtensionProvider](src/me/dslengine/extension/LanguageExtensionProvider.groovy) interface. This interface has a single method `extend(script)` that you will\r\nimplement when you want to extend the core language, like meta-programming `java.lang.String` or `java.lang.Number`. I'll list out what steps are required to actually create a simple DSL, you can also look at the same code in the test directory if you'd prefer.\r\n\r\n**Simple Class Diagram**\r\n\r\n![Parts of the engine.](docs/dslengine.png)\r\n\r\n\r\n### Using diesel engine\r\n\r\n**Build from repository**\r\n\r\nTo work through the example below or to use diesel engine you'll need the **dslengine-x.x.x.jar** file. You can clone this repository and build the required jar file with Gant. Everything you need is in the project itself.\r\nThere are no external dependencies other than Groovy and Gant. To build the jar run the following:\r\n\r\n    $ gant all\r\n\r\nYou'll end up with the jar in the `dist` directory.\r\n\r\n**Download jar from latest release.**\r\n\r\nYou can also download the latest release jar from the [releases](https://github.com/eyeszack/diesel-engine/releases) page if you don't want to clone and build.\r\n\r\n### Example Debugging DSL \r\n\r\nIn this example we'll create a DSL that supports two keywords, `debug` and `echo`. The only function these keywords perform, is to print any string or number passed to it.\r\n\r\n**1)** First we'll implement the [KeywordProvider](src/me/dslengine/keyword/KeywordProvider.groovy) interface so that we can define our debugging keywords. In this example we use the [Keyword](src/me/dslengine/keyword/Keyword.groovy) class directly versus extending it and creating our own class. You can choose how you prefer to do this.\r\n\r\n**DebuggingKeywordProvider.groovy**\r\n   \r\n    package your.package\r\n    \r\n    import me.dslengine.keyword.*\r\n\r\n    class DebuggingKeywordProvider implements KeywordProvider {\r\n    \tdef keywords = []\r\n    \r\n        def description = \"Debugging Keywords - for testing Diesel Engine!!\"\r\n       \r\n        void addKeyword(keyword) {\r\n            keywords << keyword\r\n        }\r\n    \r\n        void addKeyword(name, help, closure, aliases) {\r\n            def newKeyword = Keyword(name:name, help:help, closure:closure, aliases:aliases)\r\n            keywords << newKeyword\r\n        }\r\n    \r\n        List<Keyword> getKeywords() {\r\n        \tdef debugKeyword = new Keyword()\r\n        \tdebugKeyword.name = \"debug\"\r\n            debugKeyword.help = \"simple echo keyword\"\r\n        \tdebugKeyword.aliases = [\"echo\"]\r\n        \tdebugKeyword.closure = { value ->\r\n\t\t        if (value instanceof List) {\r\n\t\t\t        value.each {\r\n\t\t\t\t        println \"DEBUG: ${it}\"\r\n\t\t\t        }\r\n\t\t        } else if (value instanceof Map) {\r\n\t\t\t        value.each { k,v ->\r\n\t\t\t\t        println \"DEBUG: ${k}:${v}\"\r\n\t\t\t        }\r\n\t\t        } else {\r\n\t\t\t        println \"DEBUG: ${value}\"\r\n\t\t        }\r\n\t        }\r\n            keywords << debugKeyword\r\n    \r\n            keywords\r\n        }\r\n    }\r\n \r\n**2)** Now compile your keyword provider class. You'll need to include the **dslengine-x.x.x.jar** in your compile classpath.\r\n\r\n**3)** Next, to actually have your keyword provider loaded and used at runtime you'll need to create a file named **me.dslengine.keyword.KeywordProvider**. In this file add a line with the fully quailified class name of your provider. If you have multiple classes you must include them each on their own line. If you copied the class in step one, your file would contain the following:\r\n\r\n**me.dslengine.keyword.KeywordProvider**\r\n\r\n    your.package.DebuggingKeywordProvider\r\n\r\n\r\n**4)** It's time to package your keyword provider in a jar and get it ready for use. Place all your classes in the jar file and place your **me.dslengine.keyword.KeywordProvider** file a directory named `services` under the `META-INF` directory of your jar. This is how java service providers are found at runtime. Your jar should contain the following files and directories:\r\n\r\n**jar file**\r\n\r\n    your/\r\n        package/\r\n            DebuggingKeywordProvider.class\r\n    META-INF/\r\n        services/\r\n            me.dslengine.keyword.KeywordProvider\r\n      \r\n**5)** This final step can be implemented in quite a few ways. You need to create a way to actually run your DSL scripts with the [DSLEngineScript](src/me/dslengine/DSLEngineScript.groovy) class. I think the easiest way is to use a groovy script and run it like a shell script. In the example script below the [DSLEngineScript](src/me/dslengine/DSLEngineScript.groovy) class is set as the script base for the groovy shell. This means that groovy scripts run in that shell will have access to your keywords. But just as important is the section of code at the beginning, it will load any jar file it finds into the runtime classpath. We created an environment variable called `DSLENGINE_HOME` that points to where we wish to run our scripts. In that location we added a `lib` directory and placed **dslengine-x.x.x.jar** and our provider jar in there.\r\n\r\n**dslengine**\r\n\r\n\r\n    #!/usr/bin/env groovy\r\n    import groovy.io.FileType\r\n\r\n    new File(\"${System.getenv()[\"DSLENGINE_HOME\"]}/lib\").eachFile(FileType.FILES) {\r\n        this.class.classLoader.rootLoader.addURL(it.toURL())\t\r\n    }\r\n\r\n    import org.codehaus.groovy.control.*\r\n\r\n    if (args) {\r\n      def configuration = new CompilerConfiguration()\r\n      configuration.setScriptBaseClass(\"me.dslengine.DSLEngineScript\")\r\n      def shell = new GroovyShell(configuration)\r\n      shell.evaluate(new File(args[0]))\r\n    } else {\r\n      println \"usage: ./dslengine <input file>\"\r\n    }\r\n\r\n**test.dsl**\r\n\r\n    debug \"Hello everyone!\"\r\n    echo \"This is cool stuff!\"\r\n    \r\nTo run, type the following in your terminal:\r\n\r\n    $ chmod 744 dslengine\r\n    $ ./dslengine test.dsl\r\n\r\n### Example Language Extension\r\n\r\nYou'll more than likely spend most of your time developing keywords for your DSL. But you may want to extend some of Groovy's core classes or the actual script at runtime. To do this you implement the [LanguageExtensionProvider](src/me/dslengine/extension/LanguageExtensionProvider.groovy) interface. In this example we'll extend `java.lang.Number` to do something silly. The beauty of this is that inheritance is supported,\r\nso `java.math.BigDecimal` will also be extended.\r\n\r\n**1)** First implement the [LanguageExtensionProvider](src/me/dslengine/extension/LanguageExtensionProvider.groovy) interface by providing an implementation for the `extend(script)` method. In this example we'll add the\r\nability to call `key String` on any number. So in your DSL if you had `89.key \"Eighty Nine\"` you'd see the following output `Eighty Nine:89` when it ran. You could also work with the `script` instance that's passed in.\r\n\r\n**NumberExtensionProvider.groovy**\r\n\r\n    package your.package\r\n    \r\n    import me.dslengine.extension.*\r\n\r\n    class NumberExtensionProvider implements LanguageExtensionProvider {\r\n\t    void extend(script) {\r\n            Number.metaClass.key = { String key ->\r\n\t\t        println \"${key}:${delegate}\"\r\n\t\t    }\t\t\r\n\t    }\r\n    }\r\n\r\n**2)** The remaining steps are the same as implementing keywords, with the exception of the service provider file. For extensions you create a file named **me.dslengine.extension.LanguageExtensionProvider** with the fully quailified class name \r\nof your extension provider. It too should be placed in the `services` directory in `META-INF` of your jar. Keywords and extensions can live together in the same jar or separate jars, they will all be found at runtime. \r\n\r\n**me.dslengine.extension.LanguageExtensionProvider**\r\n\r\n    your.package.NumberExtensionProvider\r\n\r\n**test.dsl**\r\n\r\n\tdebug \"Hello everyone!\"\r\n\techo \"This is cool stuff!\"\r\n\t89.key \"Eighty Nine\"\r\n\tdef test = new BigDecimal(99)\r\n\ttest.key \"wow\"\r\n  \r\n## License\r\n\r\nIt's all good! :)\r\n\r\nCopyright (c) 2014 Isaac A. Gomez See the [LICENSE](LICENSE) file for license rights and limitations (MIT).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}